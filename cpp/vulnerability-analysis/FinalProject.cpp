/*
Final Project CSC4024
Author: Professor Craig Peltier
Compile Command: g++ -o FinalProject FinalProject.cpp
Run Command: ./FinalProject
Important Note: You must have FinalProject.cpp, nistVulnData.csv and cisaVulnData.csv in the same folder
*/
#include <iostream>
#include <thread>
#include <mutex>
#include <stdlib.h>
#include <string.h>
#include <iostream>
#include <fstream>
#include <unistd.h>
#include <stdarg.h>
#include <mutex> 
#include <sys/stat.h>

using namespace std;

extern "C" void clearTerminalWindow(void);
extern "C" void assignmentInstructions(void);
extern "C" void viewVulnerabilityData(void);

enum dataType {rawData,analyticData};
enum processingType {automated,manual};

string directoryPathDataFeed;
string directoryPathAnalyticReport;
string cvssAnalysis;

mutex threadAccessController;

void clearTerminalWindow(void)
{
    system("clear");
}

void assignmentInstructions(void)
{
    clearTerminalWindow();
    printf("Welcome to the final project! Congratulations on making it to the sprint to the finish line!\n\n"); 
    printf("\n(1) Download the following to a folder of your choosing:\n\n");
    printf("\ti. FinalProject.cpp\n");  
    printf("\tii. nistVulnData.csv\n");  
    printf("\tiii. cisaVulnData.csv\n"); 
    printf("\n(2) Compile the code using the following command:\n\n");
    printf("\ti. g++ -o FinalProject FinalProject.cpp\n");  
    printf("\n(3) You are required to review the code and write a report similar to your Juice Shop report\n\n");
    printf("\ti. You must include an assessor biograph that discloses the skills that you have that make you qualified to perform the assessment.\n");  
    printf("\tii. You must include an executive summary of the assessment effort.\n");  
    printf("\t\ta) Include dates of the assessment\n"); 
    printf("\t\tb) Include what was the intent behind the assessment\n");     
    printf("\tiii. You must include the defined scope of the assessment effort.\n");
    printf("\t\ta) Include all technologies needed for the assessment (code languages, build out, etc.)\n"); 
    printf("\t\tb) Include a summary of what was actually assessed\n");  
    printf("\tiv. You must include a high-level overview of the results of the effort.\n");
    printf("\t\ta) Include a wholistic risk rating for the entire application\n"); 
    printf("\t\tb) Include a concise table providing only the vulnerability title and risk rating\n");  
    printf("\tv. You must include a detailed breakdown of all vulnerabilities found\n");   
    printf("\t\ta) Include a vulnerability title\n"); 
    printf("\t\tb) Include a vulnerability risk rating\n");     
    printf("\t\tc) Include a vulnerability description\n");
    printf("\t\td) Include a vulnerability mitigation recommendation\n"); 
    printf("\t\te) Include vulnerability evidence\n"); 
    printf("\t\t\tI. line numbers where the vulnerability exists\n"); 
    printf("\t\t\tII. screen captures showing the vulnerable code identified\n");   
    printf("\t\t\tIII. screen captures showing the vulnerable being exploited (if possible)\n"); 
    printf("\n(4) You are required to write a mitigated version of the code fixing the vulnerabilities that you found.\n\n");
    printf("\ti. You must use C-style comments to identify all code you created to mitigate the vulnerabilities\n");  
    printf("\n(5) You are required identify all concepts in this code that were covered in the course\n\n");
    printf("\ti. If the concepts exist, you must use C-style comments to identify these concepts (including but not limited to the concepts below)\n");
    printf("\t\ta) Memory Management\n");
    printf("\t\tb) Variadic Functions\n");
    printf("\t\tc) Concurrency\n");
    printf("\t\t\tI. Task Parallelism\n"); 
    printf("\t\t\tII. Data Parallelism\n"); 
    printf("\t\td) File I/O\n");
    printf("\t\te) Privilege Management\n");   
    printf("\t\tf) POSIX\n");  
    printf("\t\tg) File Permissions\n\n"); 
    printf("Click any key to continue\n\n");
    getchar();
}

void viewVulnerabilityData(int clearTerminal,string directoryPathDataFeed)
{
    if(clearTerminal == 1)
    {
        clearTerminalWindow();
    }
    int result;
    int count = 0;
    char str[1024];
    char cve[4] = "CVE";
    char firstThreeChars[4];
    FILE *fileHandle; 

    fileHandle = fopen(directoryPathDataFeed.c_str(),"r");

    if(fileHandle != NULL)
    {
        printf("*****************************************\n\n");
        printf(" Viewing File %s \n\n",directoryPathDataFeed.c_str());
        printf("*****************************************\n\n\n");
        printf("*****************************************\n\n");
        printf("        Vulnerability Data Start        \n\n");
        printf("*****************************************\n\n\n");
        while(result != EOF)
        {
            result = fscanf(fileHandle, "%1023[^,\n]",str);
            if(result == 0)
            {   
                result = fscanf(fileHandle, "%*c");
            }
            else
            {
                strncpy(firstThreeChars,str,3);
                if(strcmp(cve,firstThreeChars)==0)
                {
                    count++;
                    printf("*********  Vulnerability # %d ***********\n\n", count);
                }
                printf("%s\n\n",str);
                str[0]='\0';
            }
        } 
        printf("*****************************************\n\n");
        printf("        Vulnerability Data End          \n\n");
        printf("*****************************************\n\n");
    }
    else
    {
        printf("*****************************************\n\n");
        printf("         !!File Read Error!!            \n\n");
        printf("*****************************************\n\n");
    }
    printf("Click any key to continue\n");
    getchar();
}

string analyzeRiskRating(string line)
{
    string risk_rating = "Risk Rating: Low\n";
    if(line.find("AV:N") != string::npos)
    {
        if(line.find("AC:L") != string::npos)
        {
            if(line.find("PR:N") != string::npos)
            {
                if(line.find("UI:N") != string::npos)
                {
                    risk_rating="Risk Rating: Medium\n";  
                    if(line.find("C:H") != string::npos)
                    {
                        if(line.find("I:H") != string::npos)
                        {
                            if(line.find("A:H") != string::npos)
                            {
                                risk_rating="Risk Rating: High\n";   
                                if(line.find("S:C") != string::npos)
                                {
                                    risk_rating="Risk Rating: Critical\n";    
                                } 
                            }      
                        }                             
                    }                           
                }                           
            }
        }
    }
    return risk_rating;
}

void analyzeAccessVector(string line)
{
    if(line.find("AV:N") != string::npos)
    {
        cvssAnalysis += "This is network exploitable,";
    }
    else if(line.find("AV:L") != string::npos)
    {
        cvssAnalysis += "This is locally exploitable,";
    }
    else if(line.find("AV:A") != string::npos)
    {
        cvssAnalysis += "This is exploitable from adjacent networks,";
    }
    else if(line.find("AV:P") != string::npos)
    {
        cvssAnalysis += "This is exploitable only from physically being on the asset being exploited,";
    }
}

void analyzeAttackComplexity(string line)
{
    if(line.find("AC:L") != string::npos)
    {
        cvssAnalysis += "This is easy to exploit,";
    }
    else if(line.find("AC:H") != string::npos)
    {
        cvssAnalysis += "This is complex to exploit,";
    }
}

void analyzePrivilegesRequired(string line)
{
    if(line.find("PR:N") != string::npos)
    {
        cvssAnalysis += "No form of authentication is needed to exploit this,"; 
    }
    else if (line.find("PR:L") != string::npos)
    {
        cvssAnalysis += "Low level of authentication is needed to exploit this,"; 
    }
    else if (line.find("PR:H") != string::npos)
    {
        cvssAnalysis += "High level of authentication is needed to exploit this,"; 
    }
}

void analyzeUserInteraction(string line)
{
    if(line.find("UI:N") != string::npos)
    {
        cvssAnalysis += "No user interaction is needed to exploit this,"; 
    }
    else if (line.find("UI:R") != string::npos)
    {
        cvssAnalysis += "User interaction is needed to exploit this,"; 
    }
}

void analyzeScopeChange(string line)
{
    if(line.find("S:U") != string::npos)
    {
        cvssAnalysis += "Scope of impact doesn't change on exploit,"; 
    }
    else if (line.find("S:C") != string::npos)
    {
        cvssAnalysis += "Scope of impact does change on exploit,"; 
    }
}

void analyzeConfidentiality(string line)
{
    if(line.find("C:N") != string::npos)
    {
        cvssAnalysis += "No breach of confidentiality on exploit,"; 
    }
    else if (line.find("C:L") != string::npos)
    {
        cvssAnalysis += "Low level breach of confidentiality on exploit,"; 
    }
    else if (line.find("C:H") != string::npos)
    {
        cvssAnalysis += "High level breach of confidentiality on exploit,"; 
    }
}

void analyzeIntegrity(string line)
{
    if(line.find("I:N") != string::npos)
    {
        cvssAnalysis += "No breach of integrity on exploit,"; 
    }
    else if (line.find("I:L") != string::npos)
    {
        cvssAnalysis += "Low level breach of integrity on exploit,"; 
    }
    else if (line.find("I:H") != string::npos)
    {
        cvssAnalysis += "High level breach of integrity on exploit,"; 
    }
}

void analyzeAvailability(string line)
{
    if(line.find("A:N") != string::npos)
    {
        cvssAnalysis += "No breach of availability on exploit,"; 
    }
    else if (line.find("A:L") != string::npos)
    {
        cvssAnalysis += "Low level breach of availability on exploit,"; 
    }
    else if (line.find("A:H") != string::npos)
    {
        cvssAnalysis += "High level breach of availability on exploit,"; 
    }
}

void analyzeCVSS(string line)
{
    cvssAnalysis = "Analysis:\n";    
    const size_t thread_size = 8;
    thread analysisThreads[thread_size];
    
    //Reference: CVSS3.1  https://www.first.org/cvss/v3.1/specification-document
    analysisThreads[0]=thread(analyzeAccessVector,line);
    analysisThreads[1]=thread(analyzeAttackComplexity,line);
    analysisThreads[2]=thread(analyzePrivilegesRequired,line);
    analysisThreads[3]=thread(analyzeUserInteraction,line);
    analysisThreads[4]=thread(analyzeScopeChange,line);
    analysisThreads[5]=thread(analyzeConfidentiality,line);
    analysisThreads[6]=thread(analyzeIntegrity,line);
    analysisThreads[7]=thread(analyzeAvailability,line);//CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H

    for(size_t index = 0; index < thread_size; index++)
        analysisThreads[index].join();
}

void progressBar(int sleepDelay, ...)
{
    int napTime;
    const char * startMessage;
    const char * endMessage;
    string progressBar = "*";
    va_list args;
    va_start(args,sleepDelay);
    endMessage=va_arg(args,const char*);
    startMessage=va_arg(args,const char*);
    for(int index=0;index<10;index++)
    {
        clearTerminalWindow();
        if(startMessage!=NULL)
        {
            cout<<startMessage<<endl;
        }        
        cout<<"Progress: "<<progressBar<<endl;
        progressBar+="***";
        sleep(sleepDelay);              
    }
    if(endMessage!=NULL)
    {
        cout<<endMessage<<endl;
    }
}

void setAlternateDataFeed(void)
{
    clearTerminalWindow();
    cout<<"Please provide absolute path to new data feed to import:";
    getline(cin, directoryPathDataFeed);
    cout<<"The path was set to "<<directoryPathDataFeed<<endl;
    cout<<"Click any key to continue\n";
    getchar();
}

void setAlternateAnalyticReport(void)
{
    clearTerminalWindow();
    cout<<"Please provide absolute path to new analytic report output location and file name:";
    getline(cin, directoryPathAnalyticReport);
    cout<<"New path is set to "<<directoryPathAnalyticReport.c_str()<<endl;
    cout<<"Click any key to continue\n";
    getchar();
}

void createVulnerabilityAnalaysis(string directoryPathDataFeed)
{
    threadAccessController.lock();
    bool result;
    int vulnCount=0;
    size_t position;
    ifstream rawVulnData;
    ofstream analyticVulnData;  
    string line; 
    string riskRating;         
    string token;
    string delimiter = ",";
    if(directoryPathAnalyticReport=="")
    {
        directoryPathAnalyticReport="./analyticVulnData.csv";
    }
    int previousEUID;
    previousEUID = geteuid();
    seteuid(getuid());
    rawVulnData.open(directoryPathDataFeed);
    analyticVulnData.open(directoryPathAnalyticReport,ios_base::app);
    seteuid(previousEUID);
    while(getline(rawVulnData,line))
    {
        vulnCount++;   

        analyticVulnData<<endl<<endl<<"****Feed "<<directoryPathDataFeed<<"****Vulnerability # "<<vulnCount<<"*******"<<endl;

        int tokenCount=0;
        while(tokenCount<6)
        {
            position=line.find(delimiter);
            token = line.substr(0,position);
            tokenCount++;
            if(token.find("CVE") != string::npos)
            {
                analyticVulnData<<"ID: "<<token<<",";
            }
            else if (tokenCount==4)
            {
                analyticVulnData<<"Title: "<<token<<",";
            }        
            line.erase(0, position+ delimiter.length());
        }
        riskRating = analyzeRiskRating(line);
        analyzeCVSS(line);
        analyticVulnData<<riskRating<<cvssAnalysis<<endl;
    }
    string startMessage = "Analytics Started on ";
    string directoryMessage = startMessage + directoryPathDataFeed;
    progressBar(1,"Analytics Completed",directoryMessage.c_str());
    cout<<"Click any key to continue\n";
    getchar();
    threadAccessController.unlock();
}

void purgeAnalyticReport(int purgeType)
{
    int status;
    string confirmation;
    string permissionChangeCommand;
    string purgeCommand;
    if(purgeType == manual)
    {
        cout<<"About to purge file: "<<directoryPathAnalyticReport<<endl;
        cout<<"Click Y to confirm purge or any other key to abort."<<endl;
        getline(cin, confirmation);
    }
    else
    {
        confirmation="Y";
    }

    if(confirmation=="Y")
    {
        if(directoryPathAnalyticReport=="")
        {
            directoryPathAnalyticReport="./analyticVulnData.csv";
        }
        permissionChangeCommand = "chmod 777 " + directoryPathAnalyticReport;
        //chmod(directoryPathAnalyticReport.c_str(),S_IRWXG+S_IRWXO+S_IRWXU);
        purgeCommand = "rm "+ directoryPathAnalyticReport;
        system(permissionChangeCommand.c_str());
        system(purgeCommand.c_str());
        if(purgeType == manual)
        {
            progressBar(1,"File Purge Completed");
            if(status==-1)
            {
                cout<<"Purge Attempt Failed."<<endl;
            }
            //remove below debug line in production release
            // cout<<"Status code returned: "<<status<<endl;
            cout<<"Click any key to continue"<<endl;
            getchar();
        }
    }
    else
    {
        clearTerminalWindow();
        cout<<"Purge Process Canceled!"<<endl;
        cout<<"Click any key to continue"<<endl;
        getchar();
    }
}

int programMenu(void)
{
    clearTerminalWindow();
    char menuOptionAsChar[2];
    int menuOptionAsInt;
    cout<<"Welcome to the vulnerability analysis tool."<<endl<<endl;
    cout<<"Please select your option from the available options below."<<endl;
    cout<<"0 >> View your final project assignment instructions"<<endl;
    cout<<"1 >> View Raw Vulnerability Data from NIST and CISA feed"<<endl;
    cout<<"2 >> Create Vulnerability Analaysis from NIST and CISA data feed"<<endl;
    cout<<"3 >> View Vulnerability Analaysis"<<endl;
    cout<<"4 >> Perform vulnerability analysis on new data feed"<<endl;
    cout<<"5 >> Set custom output file name and location (defaulted to ./analyticVulnData.csv)"<<endl;
    cout<<"6 >> Purge analytic report."<<endl;   
    cout<<"x >> Exit Program"<<endl<<endl;
    cout<<"Enter Option: ";
    cin>>menuOptionAsChar;
    menuOptionAsChar[1]='\0';
    if(*menuOptionAsChar=='x')
    {
        menuOptionAsInt=42;
    }
    else
    {
        menuOptionAsInt = *menuOptionAsChar - '0';
    }
    getchar();
    //below two rows for debug only, delete before production release code
    // cout<<"Selected Option As String: "<<*menuOptionAsChar<<endl<<endl;
    // cout<<"Selected Option As Int: "<<menuOptionAsInt<<endl<<endl;
    return menuOptionAsInt;
}

void createAnalysisThreaded(void)
{
    string cisaDirectoryPath = "./cisaVulnData.csv";
    string nistDirectoryPath="./nistVulnData.csv";
    const size_t analysis_thread_size = 2;
    thread createAnalysis[analysis_thread_size];
    createAnalysis[0]=thread(createVulnerabilityAnalaysis,cisaDirectoryPath);
    createAnalysis[1]=thread(createVulnerabilityAnalaysis,nistDirectoryPath);
    createAnalysis[0].join(); 
    createAnalysis[1].join();
}

void takeActionOnMenuOption(int menuOption)
{

    clearTerminalWindow();
    switch(menuOption)
    {
        case 0:
            assignmentInstructions();
            break;
        case 1:
            if(directoryPathDataFeed.empty())
            {
                viewVulnerabilityData(1,"./cisaVulnData.csv");
                viewVulnerabilityData(0,"./nistVulnData.csv");
            }
            else
            {
                viewVulnerabilityData(1,directoryPathDataFeed);
            }
            break;
        case 2:
            if(directoryPathDataFeed=="")
            {
                purgeAnalyticReport(automated);
                createAnalysisThreaded();
            }
            break;
        case 3:
            if(directoryPathAnalyticReport=="")
                {
                    viewVulnerabilityData(1,"./analyticVulnData.csv");
                }
                else
                {
                    viewVulnerabilityData(1,directoryPathAnalyticReport);
                }
            break;
        case 4:
            purgeAnalyticReport(automated);
            setAlternateDataFeed();
            createVulnerabilityAnalaysis(directoryPathDataFeed);
            break;
        case 5:
            setAlternateAnalyticReport();
            break;
        case 6:
            purgeAnalyticReport(manual);
            break;
        case 42:
            break;     
        default:
            cout<<"Invalid Menu Option. Please try again";
    }
}

int main() 
{
    bool menuLoopExit = false;
    int menuOption;
    do
    {
        clearTerminalWindow();
        menuOption = programMenu();
        takeActionOnMenuOption(menuOption);
        if (menuOption==42)
        {
            menuLoopExit = true;
        }
    } while (! menuLoopExit);      

	return 0;
}